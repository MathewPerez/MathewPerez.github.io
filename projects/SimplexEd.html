<html>
    <head>
        <meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">.lst-kix_d16f0lo9q4ij-8>li:before{content:"\0025a0  "}.lst-kix_d16f0lo9q4ij-6>li:before{content:"\0025cf  "}.lst-kix_d16f0lo9q4ij-7>li:before{content:"\0025cb  "}.lst-kix_d16f0lo9q4ij-5>li:before{content:"\0025a0  "}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}ul.lst-kix_d16f0lo9q4ij-4{list-style-type:none}.lst-kix_d16f0lo9q4ij-2>li:before{content:"\0025a0  "}.lst-kix_d16f0lo9q4ij-3>li:before{content:"\0025cf  "}ul.lst-kix_d16f0lo9q4ij-5{list-style-type:none}ul.lst-kix_d16f0lo9q4ij-2{list-style-type:none}ul.lst-kix_d16f0lo9q4ij-3{list-style-type:none}ul.lst-kix_d16f0lo9q4ij-8{list-style-type:none}.lst-kix_d16f0lo9q4ij-0>li:before{content:"\0025cf  "}.lst-kix_d16f0lo9q4ij-4>li:before{content:"\0025cb  "}ul.lst-kix_d16f0lo9q4ij-6{list-style-type:none}ul.lst-kix_d16f0lo9q4ij-7{list-style-type:none}ul.lst-kix_d16f0lo9q4ij-0{list-style-type:none}.lst-kix_d16f0lo9q4ij-1>li:before{content:"\0025cb  "}ul.lst-kix_d16f0lo9q4ij-1{list-style-type:none}ol{margin:0;padding:0}table td,table th{padding:0}.c8{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;background-color:#000000;border-left-style:solid;border-bottom-width:1pt;width:468pt;border-top-color:#000000;border-bottom-style:solid}.c0{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c4{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c22{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c3{background-color:#1e1e1e;padding-top:0pt;padding-bottom:0pt;line-height:1.5;text-align:left}.c21{color:#000000;font-weight:700;font-size:12pt;font-family:"Arial"}.c17{font-size:9pt;font-family:"Courier New";color:#4ec9b0;font-weight:400}.c12{font-size:9pt;font-family:"Courier New";color:#ce9178;font-weight:400}.c5{font-size:9pt;font-family:"Courier New";color:#b5cea8;font-weight:400}.c18{color:#000000;font-weight:400;font-size:12pt;font-family:"Arial"}.c2{font-size:9pt;font-family:"Courier New";color:#dcdcaa;font-weight:400}.c6{font-size:9pt;font-family:"Courier New";color:#569cd6;font-weight:400}.c15{font-size:9pt;font-family:"Courier New";color:#c586c0;font-weight:400}.c14{font-size:9pt;font-family:"Courier New";color:#9cdcfe;font-weight:400}.c11{border-spacing:0;border-collapse:collapse;margin-right:auto}.c1{font-size:9pt;font-family:"Courier New";color:#d4d4d4;font-weight:400}.c26{color:#000000;font-weight:700;font-size:11pt;font-family:"Arial"}.c25{color:#000000;font-weight:700;font-size:14pt;font-family:"Arial"}.c24{color:#6a9955;font-weight:400;font-size:9pt;font-family:"Courier New"}.c20{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c27{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c9{text-decoration:none;vertical-align:baseline;font-style:normal}.c7{color:inherit;text-decoration:inherit}.c28{padding:0;margin:0}.c19{margin-left:36pt;padding-left:0pt}.c23{font-size:12pt}.c16{font-style:italic}.c29{font-weight:700}.c10{height:11pt}.c13{height:0pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style>
    </head>
    <body class="c27">
        <p class="c4"><span class="c9 c25">SimplexEd - Linear Programming Library</span></p><p class="c4"><span class="c20 c23"><a class="c7" href="https://www.google.com/url?q=https://github.com/MathewPerez/SimplexEd&amp;sa=D&amp;ust=1611530421421000&amp;usg=AOvVaw0mjai-QEigdqTFWC3DE372">Code Repository</a></span></p><p class="c4 c10"><span class="c9 c26"></span></p><p class="c4"><span class="c23 c29">Intro</span></p><p class="c4"><span class="c0">There are many useful applications of linear programming, that is optimizing some linear function subject to some linear constraints. A popular method for linear programming is the Simplex Algorithm. SimplexEd is a simple implementation of the Simplex Algorithm in Python to facilitate understanding and learning Simplex&rsquo;s details. Of course it is limited in the cases of degeneracy and worst-case runtimes, just as the normal Simplex Algorithm inherently is. We will move on to how SimplexEd was built and how to reproduce the necessary functions and classes.</span></p><p class="c4 c10"><span class="c0"></span></p><p class="c4"><span class="c21 c9">The Algorithm</span></p><p class="c4"><span class="c0">I highly recommend reading some helpful documents first to mathematically understand the Simplex Algorithm:</span></p><ul class="c28 lst-kix_d16f0lo9q4ij-0 start"><li class="c4 c19 li-bullet-0"><span class="c20"><a class="c7" href="https://www.google.com/url?q=https://www.cs.cmu.edu/~15451-f17/handouts/simplex.pdf&amp;sa=D&amp;ust=1611530421422000&amp;usg=AOvVaw3P2caUeDhZ2hNEbw_qBXAx">Good introduction to the topic</a></span></li><li class="c4 c19 li-bullet-0"><span class="c20"><a class="c7" href="https://www.google.com/url?q=https://personal.utdallas.edu/~scniu/OPRE-6201/documents/LP4-Simplex.html&amp;sa=D&amp;ust=1611530421422000&amp;usg=AOvVaw17ns-9YWJSSjI7shhtJqOy">High-Level Description</a></span></li><li class="c4 c19 li-bullet-0"><span class="c20"><a class="c7" href="https://www.google.com/url?q=https://personal.utdallas.edu/~scniu/OPRE-6201/documents/LP06-Simplex-Tableau.pdf&amp;sa=D&amp;ust=1611530421423000&amp;usg=AOvVaw3_rCq4W_AWA1wCOQMpX08G">Example Problem</a></span></li><li class="c4 c19 li-bullet-0"><span class="c20"><a class="c7" href="https://www.google.com/url?q=https://web.stanford.edu/group/sisl/k12/optimization/MO-unit3-pdfs/3.5pivoting.pdf&amp;sa=D&amp;ust=1611530421423000&amp;usg=AOvVaw09RlJURrNsxd0v_7aX1BJP">How to read solution from tableau</a></span></li></ul><p class="c4 c10"><span class="c0"></span></p><p class="c4"><span class="c0">After reading the proper materials we&rsquo;ll now discuss how we&rsquo;ll implement the algorithm.</span></p><p class="c4 c10"><span class="c0"></span></p><p class="c4"><span class="c21 c9">Library Design</span></p><p class="c4"><span>SimplexEd is constructed around the LP class. This class defines a Linear Programming problem instance. In order to create an LP object, its constructor arguments must be checked to ensure they adhere to the canonical form associated with the Simplex Algorithm. We define our canonical form as follows (from </span><span class="c20"><a class="c7" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Simplex_algorithm&amp;sa=D&amp;ust=1611530421424000&amp;usg=AOvVaw0mUB0koZDkvExyeC_D7Wen">Simplex</a></span><span class="c0">&nbsp;wikipedia page) :</span></p><p class="c4 c10"><span class="c0"></span></p><p class="c22"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 318.50px; height: 79.63px;"><img alt="" src="images/SimplexEdImgs/image1.png" style="width: 318.50px; height: 79.63px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span>The LP class must be instantiated with three arguments: </span><span class="c16">c</span><span>&nbsp;(objective function&rsquo;s coefficients vector), </span><span class="c16">A</span><span>&nbsp;(matrix representing the coefficients of the constraints), and </span><span class="c16">b</span><span class="c0">&nbsp;(the right-hand side values of the constraints). We create the is_canonical function to ensure that the canonical form is followed. In the constructor, if the check doesn&rsquo;t pass, then an error is thrown. If it does pass, then we create the object and call the to_tableau function to build the tableau - the fundamental attribute of our class. The other class methods simply read or write to this tableau attribute or set the pivot row or column attribute.</span></p><p class="c4 c10"><span class="c0"></span></p><p class="c4"><span class="c9 c21">Building the Tableau</span></p><p class="c4"><span class="c0">The basic idea is laid out in this form:</span></p><p class="c4 c10"><span class="c0"></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 257.50px; height: 113.84px;"><img alt="" src="images/SimplexEdImgs/image2.png" style="width: 257.50px; height: 113.84px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span>We&rsquo;ll assume that the user has made the c vector negative already. Of course, depending on the size of </span><span class="c16">A</span><span>&nbsp;and </span><span class="c16">b</span><span class="c0">&nbsp;we&rsquo;ll have to add more zeros to the first column and we need to represent slack variables somehow.</span></p><p class="c4 c10"><span class="c0"></span></p><a id="t.c5e1cba999777ab4b965aaab1c311688b2c3fa61"></a><a id="t.0"></a><table class="c11"><tbody><tr class="c13"><td class="c8" colspan="1" rowspan="1"><p class="c3"><span class="c6">def</span><span class="c1">&nbsp;</span><span class="c2">to_tableau</span><span class="c1">(</span><span class="c14">c</span><span class="c1">: List[</span><span class="c17">float</span><span class="c1">], </span><span class="c14">A</span><span class="c1">: List[List[</span><span class="c17">float</span><span class="c1">]], </span><span class="c14">b</span><span class="c1">: List[</span><span class="c17">float</span><span class="c1">]) -&gt; np.array([np.array([</span><span class="c17">float</span><span class="c1 c9">])]):</span></p><p class="c3"><span class="c1">&nbsp; &nbsp;n = </span><span class="c2">len</span><span class="c1 c9">(c)</span></p><p class="c3"><span class="c1">&nbsp; &nbsp;p = </span><span class="c2">len</span><span class="c1 c9">(A)</span></p><p class="c3"><span class="c1">&nbsp; &nbsp;</span><span class="c24 c9"># Define the lower rows of tableau</span></p><p class="c3"><span class="c1">&nbsp; &nbsp;A_sub = np.array(A, </span><span class="c14">dtype</span><span class="c1">=</span><span class="c17">float</span><span class="c1 c9">)</span></p><p class="c3"><span class="c1">&nbsp; &nbsp;slack_vars = np.eye(p, </span><span class="c14">dtype</span><span class="c1">=</span><span class="c17">float</span><span class="c1 c9">)</span></p><p class="c3"><span class="c1">&nbsp; &nbsp;b_sub = np.reshape(np.array(b, </span><span class="c14">dtype</span><span class="c1">=</span><span class="c17">float</span><span class="c1">), (p,</span><span class="c5">1</span><span class="c1 c9">))</span></p><p class="c3"><span class="c1">&nbsp; &nbsp;lower_rows = np.concatenate((np.zeros((p,</span><span class="c5">1</span><span class="c1">)),A_sub, slack_vars, b_sub), </span><span class="c14">axis</span><span class="c1">=</span><span class="c5">1</span><span class="c1 c9">)</span></p><p class="c3"><span class="c1">&nbsp; &nbsp;</span><span class="c9 c24"># Define top row which corresponds to objective function</span></p><p class="c3"><span class="c1 c9">&nbsp; &nbsp;c_cop = copy.copy(c)</span></p><p class="c3"><span class="c1">&nbsp; &nbsp;c_cop.insert(</span><span class="c5">0</span><span class="c1">, </span><span class="c5">1.0</span><span class="c1 c9">)</span></p><p class="c3"><span class="c1">&nbsp; &nbsp;t_sub = np.array(c_cop, </span><span class="c14">dtype</span><span class="c1">=</span><span class="c17">float</span><span class="c1 c9">)</span></p><p class="c3"><span class="c1">&nbsp; &nbsp;top_row = np.concatenate((t_sub, np.zeros((p+</span><span class="c5">1</span><span class="c1">))), </span><span class="c14">axis</span><span class="c1">=</span><span class="c5">0</span><span class="c1 c9">)</span></p><p class="c3"><span class="c1">&nbsp; &nbsp;</span><span class="c15">return</span><span class="c1">&nbsp;np.insert(lower_rows, </span><span class="c5">0</span><span class="c1">, top_row, </span><span class="c14">axis</span><span class="c1">=</span><span class="c5">0</span><span class="c1">)</span></p></td></tr></tbody></table><p class="c4 c10"><span class="c0"></span></p><p class="c4"><span class="c0">The lower rows of the tableau consist of a column of zeros, the constraint coefficients in A, the slack variable coefficients (which are either 1 or 0), and the right-hand side values in b. We&rsquo;ll have a slack variable for each constraint. This is represented with a coefficient of 1 in a given row, and all other slack variables will have a coefficient of zero in that row. Clearly, the slack variables are then just a pxp identity matrix (p=number of constraints). Thus, the lower rows are built by converting A and b to numpy arrays, building a pxp identity matrix, and then concatenating them all together along with that first column of zeros.</span></p><p class="c4"><span class="c0">Next, all we have to do is insert the top row. We create the top row by putting a 1 at the front of the c vector and then concatenating that with p+1 zeros. Lastly, just insert the top row on top of the lower rows and we have our initial tableau.</span></p><p class="c4 c10"><span class="c0"></span></p><p class="c4"><span class="c21 c9">Finding pivot column and row</span></p><p class="c4"><span class="c0">Next, we must set the target column and row before we can execute a pivot. We find the pivot column by finding the most negative coefficient in the objective function (top row of tableau). We must remember that the first and last element of the top row do not represent coefficients so we exclude them from this process. </span></p><p class="c4 c10"><span class="c0"></span></p><a id="t.1b9b6f94b01f331a3cf96470169dc2b230326783"></a><a id="t.1"></a><table class="c11"><tbody><tr class="c13"><td class="c8" colspan="1" rowspan="1"><p class="c3"><span class="c1">&nbsp; &nbsp;</span><span class="c24 c9"># Choose the pivot column w.r.t. current tableau state</span></p><p class="c3"><span class="c1">&nbsp; &nbsp;</span><span class="c6">def</span><span class="c1">&nbsp;</span><span class="c2">getPivCol</span><span class="c1">(</span><span class="c14">self</span><span class="c1 c9">):</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c24 c9"># Bland&#39;s rule used since argmin returns first occurrence</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;entv = np.argmin(</span><span class="c6">self</span><span class="c1">.tab[</span><span class="c5">0</span><span class="c1">][</span><span class="c5">1</span><span class="c1">:-</span><span class="c5">1</span><span class="c1">])+</span><span class="c5 c9">1</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6">self</span><span class="c1">.pcol = entv</span></p></td></tr></tbody></table><p class="c4 c10"><span class="c0"></span></p><p class="c4"><span class="c0">Then, we must find the pivot row. We do this via the ratio test. This is done by first finding the non-negative values in the pivot column. Then, we find these values&rsquo; corresponding rhs values (i.e. the last column). We divide those values in the last column by the corresponding values in the pivot column, giving us a ratio. Choose the row corresponding to the minimum ratio as the pivot row. </span></p><p class="c4 c10"><span class="c0"></span></p><a id="t.b2a5e15b7d0f1bbbcdba889855239151ccabaf3b"></a><a id="t.2"></a><table class="c11"><tbody><tr class="c13"><td class="c8" colspan="1" rowspan="1"><p class="c3"><span class="c1">&nbsp; &nbsp;</span><span class="c6">def</span><span class="c1">&nbsp;</span><span class="c2">getPivRow</span><span class="c1">(</span><span class="c14">self</span><span class="c1 c9">):</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c15">if</span><span class="c1">&nbsp;(</span><span class="c6">not</span><span class="c1">&nbsp;</span><span class="c6">self</span><span class="c1 c9">.pcol):</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c15">raise</span><span class="c1">&nbsp;</span><span class="c17">ValueError</span><span class="c1">(</span><span class="c12">&quot;pcol attribute must be set to obtain prow&quot;</span><span class="c1 c9">)</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;tgt_col = </span><span class="c6">self</span><span class="c1">.tab[:,</span><span class="c6">self</span><span class="c1 c9">.pcol]</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;rhs_col = </span><span class="c6">self</span><span class="c1">.tab[:,-</span><span class="c5">1</span><span class="c1 c9">]</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;non_zero_idx = np.nonzero(tgt_col&gt;</span><span class="c5">0</span><span class="c1">)[</span><span class="c5">0</span><span class="c1 c9">]</span></p><p class="c3"><span class="c1 c9">&nbsp; &nbsp; &nbsp; &nbsp;non_zero_vals = tgt_col[non_zero_idx]</span></p><p class="c3"><span class="c1 c9">&nbsp; &nbsp; &nbsp; &nbsp;rhs_vals = rhs_col[non_zero_idx]</span></p><p class="c3"><span class="c1 c9">&nbsp; &nbsp; &nbsp; &nbsp;ratios = np.divide(rhs_vals, non_zero_vals)</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6">self</span><span class="c1">.prow = non_zero_idx[np.argmin(ratios)]</span></p></td></tr></tbody></table><p class="c4 c10"><span class="c0"></span></p><p class="c4"><span class="c21 c9">Executing a Pivot</span></p><p class="c4"><span class="c0">Pivoting is done with Gaussian elimination, which will just consist of some row transformations on our tableau. What we must do for all rows, except the pivot row, is add each to the product of a multiplier value and the pivot row. For the pivot row itself, we just multiply it by a multiplier value. We first must define a pivot value which will be used to derive our row multipliers. The pivot value is at the tableau[i,j] location, where i is the pivot row and j is the pivot column. </span></p><p class="c4 c10"><span class="c0"></span></p><p class="c4"><span class="c0">To generate the multipliers for all rows besides the pivot row, we multiply the pivot column&rsquo;s values by negative one and divide them by the pivot value. The multiplier for the pivot row is simply 1 divided by the pivot value. With the multipliers calculated, we make the initial transformation by multiplying each row by its respective multiplier. Then we add these vector-scalar products to the original rows. Lastly, make sure the pivot row is not added (i.e. it should just be the vector-scalar product from the initial transformation). Once this is done, we have completed a pivot.</span></p><p class="c4 c10"><span class="c0"></span></p><a id="t.6978d80a7e2179da5d6bf46af36f8ca87162fdb2"></a><a id="t.3"></a><table class="c11"><tbody><tr class="c13"><td class="c8" colspan="1" rowspan="1"><p class="c3"><span class="c1">&nbsp; &nbsp;</span><span class="c6">def</span><span class="c1">&nbsp;</span><span class="c2">pivot</span><span class="c1">(</span><span class="c14">self</span><span class="c1 c9">):</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c15">if</span><span class="c1">&nbsp;(</span><span class="c6">not</span><span class="c1">&nbsp;</span><span class="c6">self</span><span class="c1 c9">.prow):</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c15">raise</span><span class="c1">&nbsp;</span><span class="c17">ValueError</span><span class="c1">(</span><span class="c12">&quot;prow and pcol attribute must be set to execute pivot&quot;</span><span class="c1 c9">)</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;piv_val = </span><span class="c6">self</span><span class="c1">.tab[</span><span class="c6">self</span><span class="c1">.prow, </span><span class="c6">self</span><span class="c1 c9">.pcol]</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;multipliers = np.divide(</span><span class="c6">self</span><span class="c1">.tab[:,</span><span class="c6">self</span><span class="c1">.pcol]*-</span><span class="c5">1</span><span class="c1 c9">., piv_val)</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;multipliers[</span><span class="c6">self</span><span class="c1">.prow] = </span><span class="c5">1.0</span><span class="c1 c9">/piv_val</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;init_transf = [</span><span class="c6">self</span><span class="c1">.tab[</span><span class="c6">self</span><span class="c1">.prow,:]*mult </span><span class="c15">for</span><span class="c1">&nbsp;mult </span><span class="c6">in</span><span class="c1 c9">&nbsp;multipliers]</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;pivoted_tab = np.add(init_transf, </span><span class="c6">self</span><span class="c1 c9">.tab)</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;pivoted_tab[</span><span class="c6">self</span><span class="c1">.prow] = init_transf[</span><span class="c6">self</span><span class="c1 c9">.prow]</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6">self</span><span class="c1">.tab = pivoted_tab</span></p></td></tr></tbody></table><p class="c4 c10"><span class="c0"></span></p><p class="c4"><span class="c21 c9">Optimization Process</span></p><p class="c4"><span class="c0">Now, to actually find the optimal solution, we must execute pivots until the coefficients in the top row of the tableau are all non-negative or some max number of iterations is reached. This is a very simple loop implementation.</span></p><p class="c4 c10"><span class="c0"></span></p><a id="t.d2c07efad4a81fe124180335e57647e227f5b554"></a><a id="t.4"></a><table class="c11"><tbody><tr class="c13"><td class="c8" colspan="1" rowspan="1"><p class="c3"><span class="c1">&nbsp; &nbsp;</span><span class="c6">def</span><span class="c1">&nbsp;</span><span class="c2">optimize</span><span class="c1">(</span><span class="c14">self</span><span class="c1">, </span><span class="c14">max_iter</span><span class="c1">: </span><span class="c17">int</span><span class="c1">&nbsp;= </span><span class="c5">10000</span><span class="c1 c9">):</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;counter = </span><span class="c5 c9">1</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c15">while</span><span class="c1 c9">&nbsp;(counter &lt; max_iter):</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c15">if</span><span class="c1">&nbsp;(np.count_nonzero(</span><span class="c6">self</span><span class="c1">.tab[</span><span class="c5">0</span><span class="c1">]&lt;</span><span class="c5">0</span><span class="c1">) == </span><span class="c5">0</span><span class="c1 c9">):</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c15 c9">break</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6">self</span><span class="c1 c9">.getPivCol()</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6">self</span><span class="c1">.getPivRow</span><span class="c1 c9">()</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6">self</span><span class="c1 c9">.pivot()</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;counter += </span><span class="c5 c9">1</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c15">if</span><span class="c1 c9">&nbsp;(counter &lt; max_iter):</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c2">print</span><span class="c1">(</span><span class="c12">&quot;Optimal solution found --- Simplex Algorithm successfully terminated&quot;</span><span class="c1 c9">)</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c15">else</span><span class="c1 c9">:</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c2">print</span><span class="c1">(</span><span class="c12">&quot;Max iterations reached&quot;</span><span class="c1">)</span></p></td></tr></tbody></table><p class="c4 c10"><span class="c0"></span></p><p class="c4"><span class="c21 c9">Decoding a Solution</span></p><p class="c4"><span class="c0">To decode the final tableau state that is left after the optimization loop finishes, we must first identify basic and non-basic variables. This is a very easy task: basic variables are those whose columns consist of one non-zero value and all the other values are zero. To find the optimal value of this subset of variables, locate the row in which the non-zero value lies in that column. Divide the corresponding rhs value (i.e. last column) for that row by the non-zero value in the basic variable&rsquo;s column. We do this for each basic variable. For non-basic variables, the optimal value is simply zero. Lastly, the optimal function value is in the top right corner of the tableau. We construct the solution as an array of the form:</span></p><p class="c4"><span class="c0">[ x_1, &hellip; ,x_n, slackvar_1, &hellip; , slackvar_p, optimal_function_value ]</span></p><p class="c4 c10"><span class="c0"></span></p><a id="t.8fb245ca1af1f9a2b52a197d864c58fe8dac28f9"></a><a id="t.5"></a><table class="c11"><tbody><tr class="c13"><td class="c8" colspan="1" rowspan="1"><p class="c3"><span class="c1">&nbsp; &nbsp;</span><span class="c6">def</span><span class="c1">&nbsp;</span><span class="c2">decode</span><span class="c1">(</span><span class="c14">self</span><span class="c1 c9">):</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;n = </span><span class="c6">self</span><span class="c1">.tab.shape[</span><span class="c5">1</span><span class="c1">]-</span><span class="c5 c9">2</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;solution = [</span><span class="c6">None</span><span class="c1 c9">]*n</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c15">for</span><span class="c1">&nbsp;i </span><span class="c6">in</span><span class="c1">&nbsp;</span><span class="c2">range</span><span class="c1">(</span><span class="c5">1</span><span class="c1">,</span><span class="c6">self</span><span class="c1">.tab.shape[</span><span class="c5">1</span><span class="c1">]-</span><span class="c5">1</span><span class="c1 c9">):</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;col = </span><span class="c6">self</span><span class="c1 c9">.tab[:,i]</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c24 c9"># Check if col is a basic var</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c15">if</span><span class="c1">&nbsp;(np.count_nonzero(col==</span><span class="c5">0</span><span class="c1">) == </span><span class="c6">self</span><span class="c1">.tab.shape[</span><span class="c5">0</span><span class="c1">]-</span><span class="c5">1</span><span class="c1 c9">):</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c24 c9"># Calculate value accordingly</span></p><p class="c3"><span class="c1 c9">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;idx = np.nonzero(col)</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;value = </span><span class="c6">self</span><span class="c1">.tab[idx,-</span><span class="c5">1</span><span class="c1 c9">]/col[idx]</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;solution[i-</span><span class="c5">1</span><span class="c1">] = value[</span><span class="c5">0</span><span class="c1">][</span><span class="c5">0</span><span class="c1 c9">]</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c15">else</span><span class="c1 c9">:</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;solution[i-</span><span class="c5">1</span><span class="c1">] = </span><span class="c5 c9">0</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;solution.append(</span><span class="c6">self</span><span class="c1">.tab[</span><span class="c5">0</span><span class="c1">,-</span><span class="c5">1</span><span class="c1 c9">])</span></p><p class="c3"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c15">return</span><span class="c1">&nbsp;solution</span></p></td></tr></tbody></table><p class="c4 c10"><span class="c0"></span></p>
    </body>
</html>